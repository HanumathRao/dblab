/* Generated by AutoLifter Â© 2014 */

package ch.epfl.data
package legobase
package deep
package scalalib

import pardis.ir._

trait HashMapOps extends Base { this: DeepDSL =>
  implicit class HashMapRep[A, B](self: Rep[HashMap[A, B]])(implicit manifestA: Manifest[A], manifestB: Manifest[B]) {
    def getOrElseUpdate(key: Rep[A], op: Rep[() => B]): Rep[B] = hashMapGetOrElseUpdate[A, B](self, key, op)(manifestA, manifestB)
    def clear(): Rep[Unit] = hashMapClear[A, B](self)(manifestA, manifestB)
    def size(): Rep[Int] = hashMapSize[A, B](self)(manifestA, manifestB)
    def remove(key: Rep[A]): Rep[Option[B]] = hashMapRemove[A, B](self, key)(manifestA, manifestB)
    def keySet(): Rep[Set[A]] = hashMapKeySet[A, B](self)(manifestA, manifestB)
  }
  // case classes
  case class HashMapNew1[A, B](contents: Rep[Contents[A, DefaultEntry[A, B]]])(implicit manifestA: Manifest[A], manifestB: Manifest[B]) extends FunctionDef[HashMap[A, B]](None, "new HashMap", List(List(contents)))
  case class HashMapNew2[A, B]()(implicit manifestA: Manifest[A], manifestB: Manifest[B]) extends FunctionDef[HashMap[A, B]](None, "new HashMap", List())
  case class HashMapGetOrElseUpdate[A, B](self: Rep[HashMap[A, B]], key: Rep[A], op: Rep[() => B])(implicit manifestA: Manifest[A], manifestB: Manifest[B]) extends FunctionDef[B](Some(self), "getOrElseUpdate", List(List(key, op)))
  case class HashMapClear[A, B](self: Rep[HashMap[A, B]])(implicit manifestA: Manifest[A], manifestB: Manifest[B]) extends FunctionDef[Unit](Some(self), "clear", List())
  case class HashMapSize[A, B](self: Rep[HashMap[A, B]])(implicit manifestA: Manifest[A], manifestB: Manifest[B]) extends FunctionDef[Int](Some(self), "size", List())
  case class HashMapRemove[A, B](self: Rep[HashMap[A, B]], key: Rep[A])(implicit manifestA: Manifest[A], manifestB: Manifest[B]) extends FunctionDef[Option[B]](Some(self), "remove", List(List(key)))
  case class HashMapKeySet[A, B](self: Rep[HashMap[A, B]])(implicit manifestA: Manifest[A], manifestB: Manifest[B]) extends FunctionDef[Set[A]](Some(self), "keySet", List())
  // method definitions
  def hashMapNew1[A, B](contents: Rep[Contents[A, DefaultEntry[A, B]]])(implicit manifestA: Manifest[A], manifestB: Manifest[B]): Rep[HashMap[A, B]] = HashMapNew1[A, B](contents)
  def hashMapNew2[A, B](implicit manifestA: Manifest[A], manifestB: Manifest[B]): Rep[HashMap[A, B]] = HashMapNew2[A, B]()
  def hashMapGetOrElseUpdate[A, B](self: Rep[HashMap[A, B]], key: Rep[A], op: Rep[() => B])(implicit manifestA: Manifest[A], manifestB: Manifest[B]): Rep[B] = HashMapGetOrElseUpdate[A, B](self, key, op)
  def hashMapClear[A, B](self: Rep[HashMap[A, B]])(implicit manifestA: Manifest[A], manifestB: Manifest[B]): Rep[Unit] = HashMapClear[A, B](self)
  def hashMapSize[A, B](self: Rep[HashMap[A, B]])(implicit manifestA: Manifest[A], manifestB: Manifest[B]): Rep[Int] = HashMapSize[A, B](self)
  def hashMapRemove[A, B](self: Rep[HashMap[A, B]], key: Rep[A])(implicit manifestA: Manifest[A], manifestB: Manifest[B]): Rep[Option[B]] = HashMapRemove[A, B](self, key)
  def hashMapKeySet[A, B](self: Rep[HashMap[A, B]])(implicit manifestA: Manifest[A], manifestB: Manifest[B]): Rep[Set[A]] = HashMapKeySet[A, B](self)
  type HashMap[A, B] = scala.collection.mutable.HashMap[A, B]
}
trait HashMapImplicits { this: HashMapComponent =>
  // Add implicit conversions here!
}
trait HashMapComponent extends HashMapOps with HashMapImplicits { self: DeepDSL => }

trait SetOps extends Base { this: DeepDSL =>
  implicit class SetRep[A](self: Rep[Set[A]])(implicit manifestA: Manifest[A]) {
    def head(): Rep[A] = setHead[A](self)(manifestA)
    def apply(elem: Rep[A]): Rep[Boolean] = setApply[A](self, elem)(manifestA)
    def toSeq(): Rep[Seq[A]] = setToSeq[A](self)(manifestA)
    def remove(elem: Rep[A]): Rep[Boolean] = setRemove[A](self, elem)(manifestA)
  }
  // case classes
  case class SetHead[A](self: Rep[Set[A]])(implicit manifestA: Manifest[A]) extends FunctionDef[A](Some(self), "head", List())
  case class SetApply[A](self: Rep[Set[A]], elem: Rep[A])(implicit manifestA: Manifest[A]) extends FunctionDef[Boolean](Some(self), "apply", List(List(elem)))
  case class SetToSeq[A](self: Rep[Set[A]])(implicit manifestA: Manifest[A]) extends FunctionDef[Seq[A]](Some(self), "toSeq", List())
  case class SetRemove[A](self: Rep[Set[A]], elem: Rep[A])(implicit manifestA: Manifest[A]) extends FunctionDef[Boolean](Some(self), "remove", List(List(elem)))
  // method definitions
  def setHead[A](self: Rep[Set[A]])(implicit manifestA: Manifest[A]): Rep[A] = SetHead[A](self)
  def setApply[A](self: Rep[Set[A]], elem: Rep[A])(implicit manifestA: Manifest[A]): Rep[Boolean] = SetApply[A](self, elem)
  def setToSeq[A](self: Rep[Set[A]])(implicit manifestA: Manifest[A]): Rep[Seq[A]] = SetToSeq[A](self)
  def setRemove[A](self: Rep[Set[A]], elem: Rep[A])(implicit manifestA: Manifest[A]): Rep[Boolean] = SetRemove[A](self, elem)
  type Set[A] = scala.collection.mutable.Set[A]
}
trait SetImplicits { this: SetComponent =>
  // Add implicit conversions here!
}
trait SetComponent extends SetOps with SetImplicits { self: DeepDSL => }

trait TreeSetOps extends Base { this: DeepDSL =>
  implicit class TreeSetRep[A](self: Rep[TreeSet[A]])(implicit manifestA: Manifest[A], ordering: Ordering[A]) {
    def head(): Rep[A] = treeSetHead[A](self)(manifestA, ordering)
    def size(): Rep[Int] = treeSetSize[A](self)(manifestA, ordering)
    def -=(elem: Rep[A]): Rep[TreeSet[A]] = treeSet$minus$eq[A](self, elem)(manifestA, ordering)
    def +=(elem: Rep[A]): Rep[TreeSet[A]] = treeSet$plus$eq[A](self, elem)(manifestA, ordering)
  }
  // case classes
  case class TreeSetHead[A](self: Rep[TreeSet[A]])(implicit manifestA: Manifest[A], ordering: Ordering[A]) extends FunctionDef[A](Some(self), "head", List())
  case class TreeSetSize[A](self: Rep[TreeSet[A]])(implicit manifestA: Manifest[A], ordering: Ordering[A]) extends FunctionDef[Int](Some(self), "size", List())
  case class TreeSet$minus$eq[A](self: Rep[TreeSet[A]], elem: Rep[A])(implicit manifestA: Manifest[A], ordering: Ordering[A]) extends FunctionDef[TreeSet[A]](Some(self), "$minus$eq", List(List(elem)))
  case class TreeSet$plus$eq[A](self: Rep[TreeSet[A]], elem: Rep[A])(implicit manifestA: Manifest[A], ordering: Ordering[A]) extends FunctionDef[TreeSet[A]](Some(self), "$plus$eq", List(List(elem)))
  // method definitions
  def treeSetHead[A](self: Rep[TreeSet[A]])(implicit manifestA: Manifest[A], ordering: Ordering[A]): Rep[A] = TreeSetHead[A](self)
  def treeSetSize[A](self: Rep[TreeSet[A]])(implicit manifestA: Manifest[A], ordering: Ordering[A]): Rep[Int] = TreeSetSize[A](self)
  def treeSet$minus$eq[A](self: Rep[TreeSet[A]], elem: Rep[A])(implicit manifestA: Manifest[A], ordering: Ordering[A]): Rep[TreeSet[A]] = TreeSet$minus$eq[A](self, elem)
  def treeSet$plus$eq[A](self: Rep[TreeSet[A]], elem: Rep[A])(implicit manifestA: Manifest[A], ordering: Ordering[A]): Rep[TreeSet[A]] = TreeSet$plus$eq[A](self, elem)
  type TreeSet[A] = scala.collection.mutable.TreeSet[A]
}
trait TreeSetImplicits { this: TreeSetComponent =>
  // Add implicit conversions here!
}
trait TreeSetComponent extends TreeSetOps with TreeSetImplicits { self: DeepDSL => }

trait DefaultEntryOps extends Base { this: DeepDSL =>
  implicit class DefaultEntryRep[A, B](self: Rep[DefaultEntry[A, B]])(implicit manifestA: Manifest[A], manifestB: Manifest[B]) {
    def chainString(): Rep[String] = defaultEntryChainString[A, B](self)(manifestA, manifestB)
  }
  // case classes
  case class DefaultEntryNew[A, B](key: Rep[A], value: Rep[B])(implicit manifestA: Manifest[A], manifestB: Manifest[B]) extends FunctionDef[DefaultEntry[A, B]](None, "new DefaultEntry", List(List(key, value)))
  case class DefaultEntryChainString[A, B](self: Rep[DefaultEntry[A, B]])(implicit manifestA: Manifest[A], manifestB: Manifest[B]) extends FunctionDef[String](Some(self), "chainString", List())
  // method definitions
  def defaultEntryNew[A, B](key: Rep[A], value: Rep[B])(implicit manifestA: Manifest[A], manifestB: Manifest[B]): Rep[DefaultEntry[A, B]] = DefaultEntryNew[A, B](key, value)
  def defaultEntryChainString[A, B](self: Rep[DefaultEntry[A, B]])(implicit manifestA: Manifest[A], manifestB: Manifest[B]): Rep[String] = DefaultEntryChainString[A, B](self)
  type DefaultEntry[A, B] = scala.collection.mutable.DefaultEntry[A, B]
}
trait DefaultEntryImplicits { this: DefaultEntryComponent =>
  // Add implicit conversions here!
}
trait DefaultEntryComponent extends DefaultEntryOps with DefaultEntryImplicits { self: DeepDSL => }

