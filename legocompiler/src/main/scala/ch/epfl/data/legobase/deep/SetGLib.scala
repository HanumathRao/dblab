/* Generated by Purgatory 2014 */

package ch.epfl.data
package legobase
package deep

import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.shallow.c.CLangTypes._
import pardis.shallow.c.GLibTypes._
import pardis.optimization._
import CTypes._
class SetOptimizations(override val IR: LoweringLegoBase) extends RecursiveRuleBasedTransformer[LoweringLegoBase](IR) with CTransformer {
  import IR._
  type Rep[T] = IR.Rep[T]
  type Var[T] = IR.Var[T]

  class T

  val gListHeadMap = scala.collection.mutable.Map[Rep[Any], Var[Any]]()

  implicit def ctp[T] = null.asInstanceOf[CType[T]]

  implicit class SetRep1[T](self: Rep[Set[T]]) {
    def gListHead_=(x$1: Rep[LPointer[LGList[T]]]): Rep[Unit] = {
      __assign(gListHeadMap(self), x$1)
    }
    def gListHead: Rep[LPointer[LGList[T]]] = {
      implicit val typeT = transformType(self.tp.typeArguments(0)).asInstanceOf[TypeRep[T]]
      val v = gListHeadMap(self).asInstanceOf[Var[LPointer[LGList[T]]]]
      __readVar(gListHeadMap(self)).asInstanceOf[Rep[LPointer[LGList[T]]]]
    }
    def evidence$1: Rep[CType[T]] = null.asInstanceOf[Rep[CType[T]]]
  }
  rewrite += statement {
    case sym -> (node @ SetNew2()) =>

      implicit val typeT = transformType(node.tp.typeArguments(0)).asInstanceOf[TypeRep[T]]

      val v = __newVar[LPointer[LGList[T]]](CLang.NULL[LGList[T]])
      gListHeadMap(sym) = v

      {
        null.asInstanceOf[Rep[Set[T]]]
      }
  }

  rewrite += statement {
    case sym -> (node @ Set$plus$eq(nodeself, nodex)) =>
      val self = nodeself.asInstanceOf[Rep[Set[T]]]
      val x = nodex.asInstanceOf[Rep[T]]
      implicit val typeT = transformType(nodeself.tp.typeArguments(0)).asInstanceOf[TypeRep[T]]

      {
        self.gListHead_$eq(LGListHeader.g_list_append[T](self.gListHead, CLang.$amp[T](x)));
        self
      }
  }

  rewrite += statement {
    case sym -> (node @ SetForeach(nodeself, nodef)) =>
      val self = nodeself.asInstanceOf[Rep[Set[T]]]
      val f = nodef.asInstanceOf[Rep[((T) => Unit)]]
      implicit val typeT = transformType(nodeself.tp.typeArguments(0)).asInstanceOf[TypeRep[T]]

      {
        var current: this.Var[ch.epfl.data.pardis.shallow.c.CLangTypes.LPointer[ch.epfl.data.pardis.shallow.c.GLibTypes.LGList[T]]] = __newVar(self.gListHead);
        __whileDo(infix_$bang$eq(__readVar(current), CLang.NULL[ch.epfl.data.pardis.shallow.c.GLibTypes.LGList[T]]), {
          val e: this.Rep[ch.epfl.data.pardis.shallow.c.CLangTypes.LPointer[T]] = LGListHeader.g_list_nth_data[T](__readVar(current), unit(0));
          __app[T, Unit](f).apply(CLang.$times[T](e));
          __assign(current, LGListHeader.g_list_next[T](__readVar(current)))
        })
      }
  }

  rewrite += statement {
    case sym -> (node @ SetRetain(nodeself, nodep)) =>
      val self = nodeself.asInstanceOf[Rep[Set[T]]]
      val p = nodep.asInstanceOf[Rep[((T) => Boolean)]]
      implicit val typeT = transformType(nodeself.tp.typeArguments(0)).asInstanceOf[TypeRep[T]]

      {
        var current: this.Var[ch.epfl.data.pardis.shallow.c.CLangTypes.LPointer[ch.epfl.data.pardis.shallow.c.GLibTypes.LGList[T]]] = __newVar(self.gListHead);
        __whileDo(infix_$bang$eq(__readVar(current), CLang.NULL[ch.epfl.data.pardis.shallow.c.GLibTypes.LGList[T]]), {
          val e: this.Rep[ch.epfl.data.pardis.shallow.c.CLangTypes.LPointer[T]] = LGListHeader.g_list_nth_data[T](__readVar(current), unit(0));
          val prev: this.Rep[ch.epfl.data.pardis.shallow.c.CLangTypes.LPointer[ch.epfl.data.pardis.shallow.c.GLibTypes.LGList[T]]] = __readVar(current);
          __assign(current, LGListHeader.g_list_next[T](__readVar(current)));
          __ifThenElse(__app[T, Boolean](p).apply(CLang.$times[T](e)), self.gListHead_$eq(LGListHeader.g_list_remove_link[T](self.gListHead, prev)), unit(()))
        })
      }
  }

}

