/* Generated by Purgatory 2014 */

package ch.epfl.data
package legobase
package deep

import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.shallow.c.CLangTypes._
import pardis.shallow.c.GLibTypes._
import pardis.optimization._
import CTypes._
class HashMapOptimizations(override val IR: LoweringLegoBase) extends RecursiveRuleBasedTransformer[LoweringLegoBase](IR) with CTransformer with ManualHashMapOptimizations {
  import IR._
  type Rep[T] = IR.Rep[T]

  class K
  class V

  implicit class HashMapRep1[K, V](self: Rep[HashMap[K, V]]) {
    def evidence$2: Rep[CType[V]] = self.asInstanceOf[Rep[CType[V]]]
    def evidence$1: Rep[CKeyType[K]] = self.asInstanceOf[Rep[CKeyType[K]]]
    def gHashTable: Rep[LPointer[LGHashTable]] = self.asInstanceOf[Rep[LPointer[LGHashTable]]]
  }
  def __newCHashMap[K, V](gHashTable: Rep[LPointer[LGHashTable]]): Rep[HashMap[K, V]] = gHashTable.asInstanceOf[Rep[HashMap[K, V]]]
  rewrite += rule {
    case HashMapNew1(gHashTable) =>
      gHashTable
  }

  rewrite += rule {
    case node @ HashMapNew2() =>

      implicit val typeK = transformType(node.tp.typeArguments(0)).asInstanceOf[TypeRep[K]]
      implicit val typeV = transformType(node.tp.typeArguments(1)).asInstanceOf[TypeRep[V]]

      {
        __newCHashMap(LGHashTableHeader.g_hash_table_new(CLang.$amp[ch.epfl.data.pardis.shallow.c.GLibTypes.gconstpointer => Int](__lambda(((s: this.Rep[ch.epfl.data.pardis.shallow.c.GLibTypes.gconstpointer]) => infix_hashCode(infix_asInstanceOf[K](s))))), CLang.$amp[(ch.epfl.data.pardis.shallow.c.GLibTypes.gconstpointer, ch.epfl.data.pardis.shallow.c.GLibTypes.gconstpointer) => ch.epfl.data.pardis.shallow.c.GLibTypes.gboolean](__lambda(((s1: this.Rep[ch.epfl.data.pardis.shallow.c.GLibTypes.gconstpointer], s2: this.Rep[ch.epfl.data.pardis.shallow.c.GLibTypes.gconstpointer]) => __ifThenElse(infix_$eq$eq(infix_asInstanceOf[K](s1), infix_asInstanceOf[K](s2)), unit(1), unit(0)))))));
      }
  }

  rewrite += rule {
    case node @ HashMapUpdate(nodeself, nodek, nodev) =>
      val self = nodeself.asInstanceOf[Rep[HashMap[K, V]]]
      val k = nodek.asInstanceOf[Rep[K]]
      val v = nodev.asInstanceOf[Rep[V]]
      implicit val typeK = transformType(self.tp.typeArguments(0)).asInstanceOf[TypeRep[K]]
      implicit val typeV = transformType(self.tp.typeArguments(1)).asInstanceOf[TypeRep[V]]

      LGHashTableHeader.g_hash_table_insert(self.gHashTable, infix_asInstanceOf[ch.epfl.data.pardis.shallow.c.GLibTypes.gconstpointer](k), infix_asInstanceOf[ch.epfl.data.pardis.shallow.c.GLibTypes.gconstpointer](v))
  }

  rewrite += rule {
    case node @ HashMapApply(nodeself, nodek) =>
      val self = nodeself.asInstanceOf[Rep[HashMap[K, V]]]
      val k = nodek.asInstanceOf[Rep[K]]
      implicit val typeK = transformType(self.tp.typeArguments(0)).asInstanceOf[TypeRep[K]]
      implicit val typeV = transformType(self.tp.typeArguments(1)).asInstanceOf[TypeRep[V]]

      infix_asInstanceOf[V](LGHashTableHeader.g_hash_table_lookup(self.gHashTable, infix_asInstanceOf[ch.epfl.data.pardis.shallow.c.GLibTypes.gconstpointer](k)))
  }

  rewrite += rule {
    case node @ HashMapSize(nodeself) =>
      val self = nodeself.asInstanceOf[Rep[HashMap[K, V]]]
      implicit val typeK = transformType(self.tp.typeArguments(0)).asInstanceOf[TypeRep[K]]
      implicit val typeV = transformType(self.tp.typeArguments(1)).asInstanceOf[TypeRep[V]]

      LGHashTableHeader.g_hash_table_size(self.gHashTable)
  }

  rewrite += rule {
    case node @ HashMapClear(nodeself) =>
      val self = nodeself.asInstanceOf[Rep[HashMap[K, V]]]
      implicit val typeK = transformType(self.tp.typeArguments(0)).asInstanceOf[TypeRep[K]]
      implicit val typeV = transformType(self.tp.typeArguments(1)).asInstanceOf[TypeRep[V]]

      LGHashTableHeader.g_hash_table_remove_all(self.gHashTable)
  }

  rewrite += rule {
    case node @ HashMapKeySet(nodeself) =>
      val self = nodeself.asInstanceOf[Rep[HashMap[K, V]]]
      implicit val typeK = transformType(self.tp.typeArguments(0)).asInstanceOf[TypeRep[K]]
      implicit val typeV = transformType(self.tp.typeArguments(1)).asInstanceOf[TypeRep[V]]

      infix_asInstanceOf[ch.epfl.data.pardis.shallow.c.CLangTypes.LPointer[ch.epfl.data.pardis.shallow.c.GLibTypes.LGList[K]]](LGHashTableHeader.g_hash_table_get_keys(self.gHashTable))
  }

  rewrite += rule {
    case node @ HashMapContains(nodeself, nodek) =>
      val self = nodeself.asInstanceOf[Rep[HashMap[K, V]]]
      val k = nodek.asInstanceOf[Rep[K]]
      implicit val typeK = transformType(self.tp.typeArguments(0)).asInstanceOf[TypeRep[K]]
      implicit val typeV = transformType(self.tp.typeArguments(1)).asInstanceOf[TypeRep[V]]

      infix_$bang$eq(LGHashTableHeader.g_hash_table_lookup(self.gHashTable, infix_asInstanceOf[ch.epfl.data.pardis.shallow.c.GLibTypes.gconstpointer](k)), CLang.NULL[Any])
  }

  rewrite += rule {
    case node @ HashMapRemove(nodeself, nodek) =>
      val self = nodeself.asInstanceOf[Rep[HashMap[K, V]]]
      val k = nodek.asInstanceOf[Rep[K]]
      implicit val typeK = transformType(self.tp.typeArguments(0)).asInstanceOf[TypeRep[K]]
      implicit val typeV = transformType(self.tp.typeArguments(1)).asInstanceOf[TypeRep[V]]

      {
        val v: this.Rep[V] = self.apply(k);
        LGHashTableHeader.g_hash_table_remove(self.gHashTable, infix_asInstanceOf[ch.epfl.data.pardis.shallow.c.GLibTypes.gconstpointer](k));
        v
      }
  }

  rewrite += rule {
    case node @ HashMapGetOrElseUpdate(nodeself, nodek, nodevOutput) =>
      val self = nodeself.asInstanceOf[Rep[HashMap[K, V]]]
      val k = nodek.asInstanceOf[Rep[K]]
      val v = nodevOutput.asInstanceOf[Block[V]]
      implicit val typeK = transformType(self.tp.typeArguments(0)).asInstanceOf[TypeRep[K]]
      implicit val typeV = transformType(self.tp.typeArguments(1)).asInstanceOf[TypeRep[V]]

      {
        val res: this.Rep[ch.epfl.data.pardis.shallow.c.GLibTypes.gpointer] = LGHashTableHeader.g_hash_table_lookup(self.gHashTable, infix_asInstanceOf[ch.epfl.data.pardis.shallow.c.GLibTypes.gconstpointer](k));
        __ifThenElse(infix_$bang$eq(res, CLang.NULL[V]), infix_asInstanceOf[V](res), {
          val vres: this.Rep[V] = v;
          self.update(k, vres);
          vres
        })
      }
  }

}

