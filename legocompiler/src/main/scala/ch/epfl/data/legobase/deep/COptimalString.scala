/* Generated by Purgatory 2014 */

package ch.epfl.data
package legobase
package deep

import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.shallow.c.CLangTypes
import pardis.optimization._
class OptimalStringOptimizations(override val IR: LoweringLegoBase) extends RecursiveRuleBasedTransformer[LoweringLegoBase](IR) with CTransformer {
  import IR._
  type Rep[T] = IR.Rep[T]
  type Var[T] = IR.Var[T]

  implicit class OptimalStringRep1(self: Rep[OptimalString]) {
    def getBaseValue(s: Rep[OptimalString]): Rep[LPointer[Char]] = s.charArray
    def charArray: Rep[LPointer[Char]] = self.asInstanceOf[Rep[LPointer[Char]]]
  }
  def __newCOptimalString(charArray: Rep[LPointer[Char]]): Rep[OptimalString] = charArray.asInstanceOf[Rep[OptimalString]]
  rewrite += rule {
    case OptimalStringNew(charArray) =>
      charArray
  }

  rewrite += statement {
    case sym -> (node @ OptimalStringString(nodeself)) =>
      val self = nodeself.asInstanceOf[Rep[OptimalString]]

      self.getBaseValue(self)
  }

  rewrite += statement {
    case sym -> (node @ OptimalStringDiff(nodeself, nodey)) =>
      val self = nodeself.asInstanceOf[Rep[OptimalString]]
      val y = nodey.asInstanceOf[Rep[OptimalString]]

      CString.strcmp(self.getBaseValue(self), self.getBaseValue(y))
  }

  rewrite += statement {
    case sym -> (node @ OptimalStringEndsWith(nodeself, nodey)) =>
      val self = nodeself.asInstanceOf[Rep[OptimalString]]
      val y = nodey.asInstanceOf[Rep[OptimalString]]

      {
        val lenx: this.Rep[ch.epfl.data.pardis.shallow.c.CLangTypes.CSize] = CString.strlen(self.getBaseValue(self));
        val leny: this.Rep[ch.epfl.data.pardis.shallow.c.CLangTypes.CSize] = CString.strlen(self.getBaseValue(y));
        val len: this.Rep[Int] = lenx.$minus(leny);
        infix_$eq$eq(CString.strncmp(CLang.pointer_add[Char](self.getBaseValue(self), len), self.getBaseValue(y), len), unit(0))
      }
  }

  rewrite += statement {
    case sym -> (node @ OptimalStringStartsWith(nodeself, nodey)) =>
      val self = nodeself.asInstanceOf[Rep[OptimalString]]
      val y = nodey.asInstanceOf[Rep[OptimalString]]

      infix_$eq$eq(CString.strncmp(self.getBaseValue(self), self.getBaseValue(y), CString.strlen(self.getBaseValue(y))), unit(0))
  }

  rewrite += statement {
    case sym -> (node @ OptimalStringCompare(nodeself, nodey)) =>
      val self = nodeself.asInstanceOf[Rep[OptimalString]]
      val y = nodey.asInstanceOf[Rep[OptimalString]]

      CString.strcmp(self.getBaseValue(self), self.getBaseValue(y))
  }

  rewrite += statement {
    case sym -> (node @ OptimalStringLength(nodeself)) =>
      val self = nodeself.asInstanceOf[Rep[OptimalString]]

      CString.strlen(self.getBaseValue(self))
  }

  rewrite += statement {
    case sym -> (node @ OptimalString$eq$eq$eq(nodeself, nodey)) =>
      val self = nodeself.asInstanceOf[Rep[OptimalString]]
      val y = nodey.asInstanceOf[Rep[OptimalString]]

      infix_$eq$eq(CString.strcmp(self.getBaseValue(self), self.getBaseValue(y)), unit(0))
  }

  rewrite += statement {
    case sym -> (node @ OptimalString$eq$bang$eq(nodeself, nodey)) =>
      val self = nodeself.asInstanceOf[Rep[OptimalString]]
      val y = nodey.asInstanceOf[Rep[OptimalString]]

      infix_$bang$eq(CString.strcmp(self.getBaseValue(self), self.getBaseValue(y)), unit(0))
  }

  rewrite += statement {
    case sym -> (node @ OptimalStringContainsSlice(nodeself, nodey)) =>
      val self = nodeself.asInstanceOf[Rep[OptimalString]]
      val y = nodey.asInstanceOf[Rep[OptimalString]]

      infix_$bang$eq(CString.strstr(self.getBaseValue(self), self.getBaseValue(y)), CLang.NULL[Char])
  }

  rewrite += statement {
    case sym -> (node @ OptimalStringIndexOfSlice(nodeself, nodey, nodeidx)) =>
      val self = nodeself.asInstanceOf[Rep[OptimalString]]
      val y = nodey.asInstanceOf[Rep[OptimalString]]
      val idx = nodeidx.asInstanceOf[Rep[Int]]

      {
        val substr: this.Rep[ch.epfl.data.pardis.shallow.c.CLangTypes.LPointer[Char]] = CString.strstr(CLang.pointer_add[Char](self.getBaseValue(self), idx), self.getBaseValue(y));
        __ifThenElse(infix_$eq$eq(substr, CLang.NULL[Char]), unit(-1), CString.str_subtract(substr, self.getBaseValue(self)))
      }
  }

  rewrite += statement {
    case sym -> (node @ OptimalStringApply(nodeself, nodeidx)) =>
      val self = nodeself.asInstanceOf[Rep[OptimalString]]
      val idx = nodeidx.asInstanceOf[Rep[Int]]

      CLang.$times[Char](CLang.pointer_add[Char](self.getBaseValue(self), idx))
  }

  rewrite += statement {
    case sym -> (node @ OptimalStringSlice(nodeself, nodestart, nodeend)) =>
      val self = nodeself.asInstanceOf[Rep[OptimalString]]
      val start = nodestart.asInstanceOf[Rep[Int]]
      val end = nodeend.asInstanceOf[Rep[Int]]

      {
        val len: this.Rep[Int] = end.$minus(start).$plus(unit(1));
        val newbuf: this.Rep[ch.epfl.data.pardis.shallow.c.CLangTypes.LPointer[Char]] = CStdLib.malloc[Char](len);
        CString.strncpy(newbuf, CLang.pointer_add[Char](self.getBaseValue(self), start), len.$minus(unit(1)));
        __newCOptimalString(newbuf)
      }
  }

}

