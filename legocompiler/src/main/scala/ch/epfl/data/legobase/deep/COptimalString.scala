/* Generated by Purgatory 2014 */

package ch.epfl.data
package legobase
package deep

import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.shallow.c.CLangTypes
import pardis.optimization._

class OptimalStringOptimizations(override val IR: LoweringLegoBase) extends RecursiveRuleBasedTransformer[LoweringLegoBase](IR) with CTransformer {
  import IR._

  type Rep[T] = IR.Rep[T]

  implicit class OptimalStringRep1(self: IR.Rep[IR.OptimalString]) {
    def getBaseValue(s: IR.Rep[IR.OptimalString]): IR.Rep[LPointer[Char]] = s.asInstanceOf[IR.Rep[LPointer[Char]]]
  }

  rewrite += rule { case OptimalStringNew(self) => self }

  rewrite += rule {
    case OptimalStringString(self) =>
      self.getBaseValue(self)
  }

  rewrite += rule {
    case OptimalStringDiff(self, y) =>
      CString.strcmp(self.getBaseValue(self), self.getBaseValue(y))
  }

  rewrite += rule {
    case OptimalStringEndsWith(self, y) =>
      {
        val lenx: this.Rep[ch.epfl.data.pardis.shallow.c.CLangTypes.CSize] = CString.strlen(self.getBaseValue(self));
        val leny: this.Rep[ch.epfl.data.pardis.shallow.c.CLangTypes.CSize] = CString.strlen(self.getBaseValue(y));
        val len: this.Rep[Int] = lenx.$minus(leny);
        infix_$eq$eq(CString.strncmp(CLang.pointer_add[Char](self.getBaseValue(self), len), self.getBaseValue(y), len), unit(0))
      }
  }

  rewrite += rule {
    case OptimalStringStartsWith(self, y) =>
      infix_$eq$eq(CString.strncmp(self.getBaseValue(self), self.getBaseValue(y), CString.strlen(self.getBaseValue(y))), unit(0))
  }

  rewrite += rule {
    case OptimalStringCompare(self, y) =>
      CString.strcmp(self.getBaseValue(self), self.getBaseValue(y))
  }

  rewrite += rule {
    case OptimalStringLength(self) =>
      CString.strlen(self.getBaseValue(self))
  }

  rewrite += rule {
    case OptimalString$eq$eq$eq(self, y) =>
      infix_$eq$eq(CString.strcmp(self.getBaseValue(self), self.getBaseValue(y)), unit(0))
  }

  rewrite += rule {
    case OptimalString$eq$bang$eq(self, y) =>
      infix_$bang$eq(CString.strcmp(self.getBaseValue(self), self.getBaseValue(y)), unit(0))
  }

  rewrite += rule {
    case OptimalStringContainsSlice(self, y) =>
      infix_$bang$eq(CString.strstr(self.getBaseValue(self), self.getBaseValue(y)), CLang.NULL[Char])
  }

  rewrite += rule {
    case OptimalStringIndexOfSlice(self, y, idx) =>
      {
        val substr: this.Rep[ch.epfl.data.pardis.shallow.c.CLangTypes.LPointer[Char]] = CString.strstr(CLang.pointer_add[Char](self.getBaseValue(self), idx), self.getBaseValue(y));
        __ifThenElse(infix_$eq$eq(substr, CLang.NULL[Char]), unit(-1), CString.str_subtract(substr, self.getBaseValue(self)))
      }
  }

  rewrite += rule {
    case OptimalStringApply(self, idx) =>
      CLang.*(CLang.pointer_add[Char](self.getBaseValue(self), idx))
  }

  rewrite += rule {
    case OptimalStringSlice(self, start, end) =>
      {
        val len: this.Rep[Int] = end.$minus(start).$plus(unit(1));
        val newbuf: this.Rep[ch.epfl.data.pardis.shallow.c.CLangTypes.LPointer[Char]] = CStdLib.malloc[Char](len);
        CString.strncpy(newbuf, CLang.pointer_add[Char](self.getBaseValue(self), start), len.$minus(unit(1)));
        newbuf
      }
  }

}

