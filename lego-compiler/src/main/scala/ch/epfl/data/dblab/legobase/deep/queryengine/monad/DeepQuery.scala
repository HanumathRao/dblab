/* Generated by Purgatory 2014-2015 */

package ch.epfl.data.dblab.legobase.deep.queryengine.monad

import ch.epfl.data.sc.pardis
import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.effects._
import pardis.deep._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.deep.scalalib.io._
trait QueryOps extends Base with ListOps { this: GroupedQueryOps =>
  // Type representation
  val QueryType = QueryIRs.QueryType
  type QueryType[T] = QueryIRs.QueryType[T]
  implicit def typeQuery[T: TypeRep]: TypeRep[Query[T]] = QueryType(implicitly[TypeRep[T]])
  implicit class QueryRep[T](self: Rep[Query[T]])(implicit typeT: TypeRep[T]) {
    def map[S](f: Rep[(T => S)])(implicit typeS: TypeRep[S]): Rep[Query[S]] = queryMap[T, S](self, f)(typeT, typeS)
    def filter(p: Rep[(T => Boolean)]): Rep[Query[T]] = queryFilter[T](self, p)(typeT)
    def foreach(f: Rep[(T => Unit)]): Rep[Unit] = queryForeach[T](self, f)(typeT)
    def sum(implicit num: Numeric[T]): Rep[T] = querySum[T](self)(typeT, num)
    def count: Rep[Int] = queryCount[T](self)(typeT)
    def avg(implicit num: Fractional[T]): Rep[T] = queryAvg[T](self)(typeT, num)
    def groupBy[K](par: Rep[(T => K)])(implicit typeK: TypeRep[K]): Rep[GroupedQuery[K, T]] = queryGroupBy[T, K](self, par)(typeT, typeK)
    def sortBy[S](f: Rep[(T => S)])(implicit typeS: TypeRep[S], ord: Ordering[S]): Rep[Query[T]] = querySortBy[T, S](self, f)(typeT, typeS, ord)
    def underlying: Rep[List[T]] = query_Field_Underlying[T](self)(typeT)
  }
  object Query {

  }
  // constructors
  def __newQuery[T](underlying: Rep[List[T]])(implicit typeT: TypeRep[T]): Rep[Query[T]] = queryNew[T](underlying)(typeT)
  // IR defs
  val QueryNew = QueryIRs.QueryNew
  type QueryNew[T] = QueryIRs.QueryNew[T]
  val QueryMap = QueryIRs.QueryMap
  type QueryMap[T, S] = QueryIRs.QueryMap[T, S]
  val QueryFilter = QueryIRs.QueryFilter
  type QueryFilter[T] = QueryIRs.QueryFilter[T]
  val QueryForeach = QueryIRs.QueryForeach
  type QueryForeach[T] = QueryIRs.QueryForeach[T]
  val QuerySum = QueryIRs.QuerySum
  type QuerySum[T] = QueryIRs.QuerySum[T]
  val QueryCount = QueryIRs.QueryCount
  type QueryCount[T] = QueryIRs.QueryCount[T]
  val QueryAvg = QueryIRs.QueryAvg
  type QueryAvg[T] = QueryIRs.QueryAvg[T]
  val QueryGroupBy = QueryIRs.QueryGroupBy
  type QueryGroupBy[T, K] = QueryIRs.QueryGroupBy[T, K]
  val QuerySortBy = QueryIRs.QuerySortBy
  type QuerySortBy[T, S] = QueryIRs.QuerySortBy[T, S]
  val Query_Field_Underlying = QueryIRs.Query_Field_Underlying
  type Query_Field_Underlying[T] = QueryIRs.Query_Field_Underlying[T]
  // method definitions
  def queryNew[T](underlying: Rep[List[T]])(implicit typeT: TypeRep[T]): Rep[Query[T]] = QueryNew[T](underlying)
  def queryMap[T, S](self: Rep[Query[T]], f: Rep[((T) => S)])(implicit typeT: TypeRep[T], typeS: TypeRep[S]): Rep[Query[S]] = QueryMap[T, S](self, f)
  def queryFilter[T](self: Rep[Query[T]], p: Rep[((T) => Boolean)])(implicit typeT: TypeRep[T]): Rep[Query[T]] = QueryFilter[T](self, p)
  def queryForeach[T](self: Rep[Query[T]], f: Rep[((T) => Unit)])(implicit typeT: TypeRep[T]): Rep[Unit] = QueryForeach[T](self, f)
  def querySum[T](self: Rep[Query[T]])(implicit typeT: TypeRep[T], num: Numeric[T]): Rep[T] = QuerySum[T](self)
  def queryCount[T](self: Rep[Query[T]])(implicit typeT: TypeRep[T]): Rep[Int] = QueryCount[T](self)
  def queryAvg[T](self: Rep[Query[T]])(implicit typeT: TypeRep[T], num: Fractional[T]): Rep[T] = QueryAvg[T](self)
  def queryGroupBy[T, K](self: Rep[Query[T]], par: Rep[((T) => K)])(implicit typeT: TypeRep[T], typeK: TypeRep[K]): Rep[GroupedQuery[K, T]] = QueryGroupBy[T, K](self, par)
  def querySortBy[T, S](self: Rep[Query[T]], f: Rep[((T) => S)])(implicit typeT: TypeRep[T], typeS: TypeRep[S], ord: Ordering[S]): Rep[Query[T]] = QuerySortBy[T, S](self, f)
  def query_Field_Underlying[T](self: Rep[Query[T]])(implicit typeT: TypeRep[T]): Rep[List[T]] = Query_Field_Underlying[T](self)
  type Query[T] = ch.epfl.data.dblab.legobase.queryengine.monad.Query[T]
}
object QueryIRs extends Base {
  import ListIRs._
  import GroupedQueryIRs._
  // Type representation
  case class QueryType[T](typeT: TypeRep[T]) extends TypeRep[Query[T]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = QueryType(newArguments(0).asInstanceOf[TypeRep[_]])
    private implicit val tagT = typeT.typeTag
    val name = s"Query[${typeT.name}]"
    val typeArguments = List(typeT)

    val typeTag = scala.reflect.runtime.universe.typeTag[Query[T]]
  }
  implicit def typeQuery[T: TypeRep]: TypeRep[Query[T]] = QueryType(implicitly[TypeRep[T]])
  // case classes
  case class QueryNew[T](underlying: Rep[List[T]])(implicit val typeT: TypeRep[T]) extends ConstructorDef[Query[T]](List(typeT), "Query", List(List(underlying))) {
    override def curriedConstructor = (copy[T] _)
  }

  case class QueryMap[T, S](self: Rep[Query[T]], f: Rep[((T) => S)])(implicit val typeT: TypeRep[T], val typeS: TypeRep[S]) extends FunctionDef[Query[S]](Some(self), "map", List(List(f))) {
    override def curriedConstructor = (copy[T, S] _).curried
  }

  case class QueryFilter[T](self: Rep[Query[T]], p: Rep[((T) => Boolean)])(implicit val typeT: TypeRep[T]) extends FunctionDef[Query[T]](Some(self), "filter", List(List(p))) {
    override def curriedConstructor = (copy[T] _).curried
  }

  case class QueryForeach[T](self: Rep[Query[T]], f: Rep[((T) => Unit)])(implicit val typeT: TypeRep[T]) extends FunctionDef[Unit](Some(self), "foreach", List(List(f))) {
    override def curriedConstructor = (copy[T] _).curried
  }

  case class QuerySum[T](self: Rep[Query[T]])(implicit val typeT: TypeRep[T], val num: Numeric[T]) extends FunctionDef[T](Some(self), "sum", List()) {
    override def curriedConstructor = (copy[T] _)
  }

  case class QueryCount[T](self: Rep[Query[T]])(implicit val typeT: TypeRep[T]) extends FunctionDef[Int](Some(self), "count", List()) {
    override def curriedConstructor = (copy[T] _)
  }

  case class QueryAvg[T](self: Rep[Query[T]])(implicit val typeT: TypeRep[T], val num: Fractional[T]) extends FunctionDef[T](Some(self), "avg", List()) {
    override def curriedConstructor = (copy[T] _)
  }

  case class QueryGroupBy[T, K](self: Rep[Query[T]], par: Rep[((T) => K)])(implicit val typeT: TypeRep[T], val typeK: TypeRep[K]) extends FunctionDef[GroupedQuery[K, T]](Some(self), "groupBy", List(List(par))) {
    override def curriedConstructor = (copy[T, K] _).curried
  }

  case class QuerySortBy[T, S](self: Rep[Query[T]], f: Rep[((T) => S)])(implicit val typeT: TypeRep[T], val typeS: TypeRep[S], val ord: Ordering[S]) extends FunctionDef[Query[T]](Some(self), "sortBy", List(List(f))) {
    override def curriedConstructor = (copy[T, S] _).curried
  }

  case class Query_Field_Underlying[T](self: Rep[Query[T]])(implicit val typeT: TypeRep[T]) extends FieldDef[List[T]](self, "underlying") {
    override def curriedConstructor = (copy[T] _)
    override def isPure = true

  }

  type Query[T] = ch.epfl.data.dblab.legobase.queryengine.monad.Query[T]
}
trait QueryImplicits extends QueryOps { this: GroupedQueryOps =>
  // Add implicit conversions here!
}
trait QueryPartialEvaluation extends QueryComponent with BasePartialEvaluation { this: GroupedQueryOps =>
  // Immutable field inlining 
  override def query_Field_Underlying[T](self: Rep[Query[T]])(implicit typeT: TypeRep[T]): Rep[List[T]] = self match {
    case Def(node: QueryNew[_]) => node.underlying
    case _                      => super.query_Field_Underlying[T](self)(typeT)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait QueryComponent extends QueryOps with QueryImplicits { this: GroupedQueryOps => }
trait ListOps extends Base {
  // Type representation
  val ListType = ListIRs.ListType
  type ListType[A] = ListIRs.ListType[A]
  implicit def typeList[A: TypeRep]: TypeRep[List[A]] = ListType(implicitly[TypeRep[A]])
  implicit class ListRep[A](self: Rep[List[A]])(implicit typeA: TypeRep[A]) {

  }
  object List {

  }
  // constructors
  def __newList[A]()(implicit typeA: TypeRep[A]): Rep[List[A]] = listNew[A]()(typeA)
  // IR defs
  val ListNew = ListIRs.ListNew
  type ListNew[A] = ListIRs.ListNew[A]
  // method definitions
  def listNew[A]()(implicit typeA: TypeRep[A]): Rep[List[A]] = ListNew[A]()
  type List[A] = scala.collection.immutable.List[A]
}
object ListIRs extends Base {
  // Type representation
  case class ListType[A](typeA: TypeRep[A]) extends TypeRep[List[A]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = ListType(newArguments(0).asInstanceOf[TypeRep[_]])
    private implicit val tagA = typeA.typeTag
    val name = s"List[${typeA.name}]"
    val typeArguments = List(typeA)

    val typeTag = scala.reflect.runtime.universe.typeTag[List[A]]
  }
  implicit def typeList[A: TypeRep]: TypeRep[List[A]] = ListType(implicitly[TypeRep[A]])
  // case classes
  case class ListNew[A]()(implicit val typeA: TypeRep[A]) extends ConstructorDef[List[A]](List(typeA), "List", List(List())) {
    override def curriedConstructor = (x: Any) => copy[A]()
  }

  type List[A] = scala.collection.immutable.List[A]
}
trait ListImplicits extends ListOps {
  // Add implicit conversions here!
}
trait ListImplementations extends ListOps {

}

trait ListPartialEvaluation extends ListComponent with BasePartialEvaluation {
  // Immutable field inlining 

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait ListComponent extends ListOps with ListImplicits {}
trait MapOps extends Base {
  // Type representation
  val MapType = MapIRs.MapType
  type MapType[A, B] = MapIRs.MapType[A, B]
  implicit def typeMap[A: TypeRep, B: TypeRep]: TypeRep[Map[A, B]] = MapType(implicitly[TypeRep[A]], implicitly[TypeRep[B]])
  implicit class MapRep[A, B](self: Rep[Map[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]) {

  }
  object Map {

  }
  // constructors
  def __newMap[A, B]()(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Map[A, B]] = mapNew[A, B]()(typeA, typeB)
  // IR defs
  val MapNew = MapIRs.MapNew
  type MapNew[A, B] = MapIRs.MapNew[A, B]
  // method definitions
  def mapNew[A, B]()(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Map[A, B]] = MapNew[A, B]()
  type Map[A, B] = scala.collection.immutable.Map[A, B]
}
object MapIRs extends Base {
  // Type representation
  case class MapType[A, B](typeA: TypeRep[A], typeB: TypeRep[B]) extends TypeRep[Map[A, B]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = MapType(newArguments(0).asInstanceOf[TypeRep[_]], newArguments(1).asInstanceOf[TypeRep[_]])
    private implicit val tagA = typeA.typeTag
    private implicit val tagB = typeB.typeTag
    val name = s"Map[${typeA.name}, ${typeB.name}]"
    val typeArguments = List(typeA, typeB)

    val typeTag = scala.reflect.runtime.universe.typeTag[Map[A, B]]
  }
  implicit def typeMap[A: TypeRep, B: TypeRep]: TypeRep[Map[A, B]] = MapType(implicitly[TypeRep[A]], implicitly[TypeRep[B]])
  // case classes
  case class MapNew[A, B]()(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends ConstructorDef[Map[A, B]](List(typeA, typeB), "Map", List(List())) {
    override def curriedConstructor = (x: Any) => copy[A, B]()
  }

  type Map[A, B] = scala.collection.immutable.Map[A, B]
}
trait MapImplicits extends MapOps {
  // Add implicit conversions here!
}
trait MapImplementations extends MapOps {

}

trait MapPartialEvaluation extends MapComponent with BasePartialEvaluation {
  // Immutable field inlining 

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait MapComponent extends MapOps with MapImplicits {}
trait GroupedQueryOps extends Base with Tuple2Ops with QueryOps with MapOps with ListOps {
  // Type representation
  val GroupedQueryType = GroupedQueryIRs.GroupedQueryType
  type GroupedQueryType[K, V] = GroupedQueryIRs.GroupedQueryType[K, V]
  implicit def typeGroupedQuery[K: TypeRep, V: TypeRep]: TypeRep[GroupedQuery[K, V]] = GroupedQueryType(implicitly[TypeRep[K]], implicitly[TypeRep[V]])
  implicit class GroupedQueryRep[K, V](self: Rep[GroupedQuery[K, V]])(implicit typeK: TypeRep[K], typeV: TypeRep[V]) {
    def mapValues[S](f: Rep[(Query[V] => S)])(implicit typeS: TypeRep[S]): Rep[Query[Tuple2[K, S]]] = groupedQueryMapValues[K, V, S](self, f)(typeK, typeV, typeS)
    def underlying: Rep[Map[K, List[V]]] = groupedQuery_Field_Underlying[K, V](self)(typeK, typeV)
  }
  object GroupedQuery {

  }
  // constructors
  def __newGroupedQuery[K, V](underlying: Rep[Map[K, List[V]]])(implicit typeK: TypeRep[K], typeV: TypeRep[V]): Rep[GroupedQuery[K, V]] = groupedQueryNew[K, V](underlying)(typeK, typeV)
  // IR defs
  val GroupedQueryNew = GroupedQueryIRs.GroupedQueryNew
  type GroupedQueryNew[K, V] = GroupedQueryIRs.GroupedQueryNew[K, V]
  val GroupedQueryMapValues = GroupedQueryIRs.GroupedQueryMapValues
  type GroupedQueryMapValues[K, V, S] = GroupedQueryIRs.GroupedQueryMapValues[K, V, S]
  val GroupedQuery_Field_Underlying = GroupedQueryIRs.GroupedQuery_Field_Underlying
  type GroupedQuery_Field_Underlying[K, V] = GroupedQueryIRs.GroupedQuery_Field_Underlying[K, V]
  // method definitions
  def groupedQueryNew[K, V](underlying: Rep[Map[K, List[V]]])(implicit typeK: TypeRep[K], typeV: TypeRep[V]): Rep[GroupedQuery[K, V]] = GroupedQueryNew[K, V](underlying)
  def groupedQueryMapValues[K, V, S](self: Rep[GroupedQuery[K, V]], f: Rep[((Query[V]) => S)])(implicit typeK: TypeRep[K], typeV: TypeRep[V], typeS: TypeRep[S]): Rep[Query[Tuple2[K, S]]] = GroupedQueryMapValues[K, V, S](self, f)
  def groupedQuery_Field_Underlying[K, V](self: Rep[GroupedQuery[K, V]])(implicit typeK: TypeRep[K], typeV: TypeRep[V]): Rep[Map[K, List[V]]] = GroupedQuery_Field_Underlying[K, V](self)
  type GroupedQuery[K, V] = ch.epfl.data.dblab.legobase.queryengine.monad.GroupedQuery[K, V]
}
object GroupedQueryIRs extends Base {
  import Tuple2IRs._
  import QueryIRs._
  import MapIRs._
  import ListIRs._
  // Type representation
  case class GroupedQueryType[K, V](typeK: TypeRep[K], typeV: TypeRep[V]) extends TypeRep[GroupedQuery[K, V]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = GroupedQueryType(newArguments(0).asInstanceOf[TypeRep[_]], newArguments(1).asInstanceOf[TypeRep[_]])
    private implicit val tagK = typeK.typeTag
    private implicit val tagV = typeV.typeTag
    val name = s"GroupedQuery[${typeK.name}, ${typeV.name}]"
    val typeArguments = List(typeK, typeV)

    val typeTag = scala.reflect.runtime.universe.typeTag[GroupedQuery[K, V]]
  }
  implicit def typeGroupedQuery[K: TypeRep, V: TypeRep]: TypeRep[GroupedQuery[K, V]] = GroupedQueryType(implicitly[TypeRep[K]], implicitly[TypeRep[V]])
  // case classes
  case class GroupedQueryNew[K, V](underlying: Rep[Map[K, List[V]]])(implicit val typeK: TypeRep[K], val typeV: TypeRep[V]) extends ConstructorDef[GroupedQuery[K, V]](List(typeK, typeV), "GroupedQuery", List(List(underlying))) {
    override def curriedConstructor = (copy[K, V] _)
  }

  case class GroupedQueryMapValues[K, V, S](self: Rep[GroupedQuery[K, V]], f: Rep[((Query[V]) => S)])(implicit val typeK: TypeRep[K], val typeV: TypeRep[V], val typeS: TypeRep[S]) extends FunctionDef[Query[Tuple2[K, S]]](Some(self), "mapValues", List(List(f))) {
    override def curriedConstructor = (copy[K, V, S] _).curried
  }

  case class GroupedQuery_Field_Underlying[K, V](self: Rep[GroupedQuery[K, V]])(implicit val typeK: TypeRep[K], val typeV: TypeRep[V]) extends FieldDef[Map[K, List[V]]](self, "underlying") {
    override def curriedConstructor = (copy[K, V] _)
    override def isPure = true

  }

  type GroupedQuery[K, V] = ch.epfl.data.dblab.legobase.queryengine.monad.GroupedQuery[K, V]
}
trait GroupedQueryImplicits extends GroupedQueryOps {
  // Add implicit conversions here!
}
trait GroupedQueryPartialEvaluation extends GroupedQueryComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def groupedQuery_Field_Underlying[K, V](self: Rep[GroupedQuery[K, V]])(implicit typeK: TypeRep[K], typeV: TypeRep[V]): Rep[Map[K, List[V]]] = self match {
    case Def(node: GroupedQueryNew[_, _]) => node.underlying
    case _                                => super.groupedQuery_Field_Underlying[K, V](self)(typeK, typeV)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}
trait GroupedQueryComponent extends GroupedQueryOps with GroupedQueryImplicits {}
